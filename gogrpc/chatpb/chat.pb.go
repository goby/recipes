// Code generated by protoc-gen-go.
// source: chat.proto
// DO NOT EDIT!

/*
Package chatpb is a generated protocol buffer package.

It is generated from these files:
	chat.proto

It has these top-level messages:
	UserInfo
	ClientInfo
	HelloRequest
	HelloResponse
	ChatMessage
	JoinRequest
	SendResponse
*/
package chatpb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ResponseCode int32

const (
	ResponseCode_Ok         ResponseCode = 0
	ResponseCode_Reject     ResponseCode = 1
	ResponseCode_BadRequest ResponseCode = 2
	ResponseCode_OverLimit  ResponseCode = 3
)

var ResponseCode_name = map[int32]string{
	0: "Ok",
	1: "Reject",
	2: "BadRequest",
	3: "OverLimit",
}
var ResponseCode_value = map[string]int32{
	"Ok":         0,
	"Reject":     1,
	"BadRequest": 2,
	"OverLimit":  3,
}

func (x ResponseCode) String() string {
	return proto.EnumName(ResponseCode_name, int32(x))
}
func (ResponseCode) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type UserInfo struct {
	ID       uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	Name     string `protobuf:"bytes,2,opt,name=Name" json:"Name,omitempty"`
	Password string `protobuf:"bytes,3,opt,name=Password" json:"Password,omitempty"`
}

func (m *UserInfo) Reset()                    { *m = UserInfo{} }
func (m *UserInfo) String() string            { return proto.CompactTextString(m) }
func (*UserInfo) ProtoMessage()               {}
func (*UserInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *UserInfo) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *UserInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *UserInfo) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

type ClientInfo struct {
	Vesion uint64 `protobuf:"varint,1,opt,name=Vesion" json:"Vesion,omitempty"`
}

func (m *ClientInfo) Reset()                    { *m = ClientInfo{} }
func (m *ClientInfo) String() string            { return proto.CompactTextString(m) }
func (*ClientInfo) ProtoMessage()               {}
func (*ClientInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *ClientInfo) GetVesion() uint64 {
	if m != nil {
		return m.Vesion
	}
	return 0
}

type HelloRequest struct {
	TimeStamp uint64      `protobuf:"varint,1,opt,name=TimeStamp" json:"TimeStamp,omitempty"`
	User      *UserInfo   `protobuf:"bytes,2,opt,name=User" json:"User,omitempty"`
	Client    *ClientInfo `protobuf:"bytes,3,opt,name=Client" json:"Client,omitempty"`
}

func (m *HelloRequest) Reset()                    { *m = HelloRequest{} }
func (m *HelloRequest) String() string            { return proto.CompactTextString(m) }
func (*HelloRequest) ProtoMessage()               {}
func (*HelloRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *HelloRequest) GetTimeStamp() uint64 {
	if m != nil {
		return m.TimeStamp
	}
	return 0
}

func (m *HelloRequest) GetUser() *UserInfo {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *HelloRequest) GetClient() *ClientInfo {
	if m != nil {
		return m.Client
	}
	return nil
}

type HelloResponse struct {
	Code    ResponseCode `protobuf:"varint,1,opt,name=Code,enum=chatpb.ResponseCode" json:"Code,omitempty"`
	Message string       `protobuf:"bytes,2,opt,name=Message" json:"Message,omitempty"`
}

func (m *HelloResponse) Reset()                    { *m = HelloResponse{} }
func (m *HelloResponse) String() string            { return proto.CompactTextString(m) }
func (*HelloResponse) ProtoMessage()               {}
func (*HelloResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *HelloResponse) GetCode() ResponseCode {
	if m != nil {
		return m.Code
	}
	return ResponseCode_Ok
}

func (m *HelloResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type ChatMessage struct {
	Message string    `protobuf:"bytes,1,opt,name=Message" json:"Message,omitempty"`
	From    *UserInfo `protobuf:"bytes,2,opt,name=From" json:"From,omitempty"`
	To      *UserInfo `protobuf:"bytes,3,opt,name=To" json:"To,omitempty"`
}

func (m *ChatMessage) Reset()                    { *m = ChatMessage{} }
func (m *ChatMessage) String() string            { return proto.CompactTextString(m) }
func (*ChatMessage) ProtoMessage()               {}
func (*ChatMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *ChatMessage) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *ChatMessage) GetFrom() *UserInfo {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *ChatMessage) GetTo() *UserInfo {
	if m != nil {
		return m.To
	}
	return nil
}

type JoinRequest struct {
	RoomID uint64    `protobuf:"varint,1,opt,name=RoomID" json:"RoomID,omitempty"`
	User   *UserInfo `protobuf:"bytes,2,opt,name=User" json:"User,omitempty"`
}

func (m *JoinRequest) Reset()                    { *m = JoinRequest{} }
func (m *JoinRequest) String() string            { return proto.CompactTextString(m) }
func (*JoinRequest) ProtoMessage()               {}
func (*JoinRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *JoinRequest) GetRoomID() uint64 {
	if m != nil {
		return m.RoomID
	}
	return 0
}

func (m *JoinRequest) GetUser() *UserInfo {
	if m != nil {
		return m.User
	}
	return nil
}

type SendResponse struct {
	Code    ResponseCode `protobuf:"varint,1,opt,name=Code,enum=chatpb.ResponseCode" json:"Code,omitempty"`
	Message string       `protobuf:"bytes,2,opt,name=Message" json:"Message,omitempty"`
}

func (m *SendResponse) Reset()                    { *m = SendResponse{} }
func (m *SendResponse) String() string            { return proto.CompactTextString(m) }
func (*SendResponse) ProtoMessage()               {}
func (*SendResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *SendResponse) GetCode() ResponseCode {
	if m != nil {
		return m.Code
	}
	return ResponseCode_Ok
}

func (m *SendResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func init() {
	proto.RegisterType((*UserInfo)(nil), "chatpb.UserInfo")
	proto.RegisterType((*ClientInfo)(nil), "chatpb.ClientInfo")
	proto.RegisterType((*HelloRequest)(nil), "chatpb.HelloRequest")
	proto.RegisterType((*HelloResponse)(nil), "chatpb.HelloResponse")
	proto.RegisterType((*ChatMessage)(nil), "chatpb.ChatMessage")
	proto.RegisterType((*JoinRequest)(nil), "chatpb.JoinRequest")
	proto.RegisterType((*SendResponse)(nil), "chatpb.SendResponse")
	proto.RegisterEnum("chatpb.ResponseCode", ResponseCode_name, ResponseCode_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Chat service

type ChatClient interface {
	// A client-to-server rpc
	Hello(ctx context.Context, in *HelloRequest, opts ...grpc.CallOption) (*HelloResponse, error)
	// A server-to-client rpc, join a room and register chat client
	Join(ctx context.Context, in *JoinRequest, opts ...grpc.CallOption) (Chat_JoinClient, error)
	// A client-to-server rpc, send message to server
	SendChatMessage(ctx context.Context, in *ChatMessage, opts ...grpc.CallOption) (*SendResponse, error)
	// Not implementation
	Chat(ctx context.Context, opts ...grpc.CallOption) (Chat_ChatClient, error)
}

type chatClient struct {
	cc *grpc.ClientConn
}

func NewChatClient(cc *grpc.ClientConn) ChatClient {
	return &chatClient{cc}
}

func (c *chatClient) Hello(ctx context.Context, in *HelloRequest, opts ...grpc.CallOption) (*HelloResponse, error) {
	out := new(HelloResponse)
	err := grpc.Invoke(ctx, "/chatpb.Chat/Hello", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatClient) Join(ctx context.Context, in *JoinRequest, opts ...grpc.CallOption) (Chat_JoinClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Chat_serviceDesc.Streams[0], c.cc, "/chatpb.Chat/Join", opts...)
	if err != nil {
		return nil, err
	}
	x := &chatJoinClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Chat_JoinClient interface {
	Recv() (*ChatMessage, error)
	grpc.ClientStream
}

type chatJoinClient struct {
	grpc.ClientStream
}

func (x *chatJoinClient) Recv() (*ChatMessage, error) {
	m := new(ChatMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *chatClient) SendChatMessage(ctx context.Context, in *ChatMessage, opts ...grpc.CallOption) (*SendResponse, error) {
	out := new(SendResponse)
	err := grpc.Invoke(ctx, "/chatpb.Chat/SendChatMessage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatClient) Chat(ctx context.Context, opts ...grpc.CallOption) (Chat_ChatClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Chat_serviceDesc.Streams[1], c.cc, "/chatpb.Chat/Chat", opts...)
	if err != nil {
		return nil, err
	}
	x := &chatChatClient{stream}
	return x, nil
}

type Chat_ChatClient interface {
	Send(*ChatMessage) error
	Recv() (*ChatMessage, error)
	grpc.ClientStream
}

type chatChatClient struct {
	grpc.ClientStream
}

func (x *chatChatClient) Send(m *ChatMessage) error {
	return x.ClientStream.SendMsg(m)
}

func (x *chatChatClient) Recv() (*ChatMessage, error) {
	m := new(ChatMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Chat service

type ChatServer interface {
	// A client-to-server rpc
	Hello(context.Context, *HelloRequest) (*HelloResponse, error)
	// A server-to-client rpc, join a room and register chat client
	Join(*JoinRequest, Chat_JoinServer) error
	// A client-to-server rpc, send message to server
	SendChatMessage(context.Context, *ChatMessage) (*SendResponse, error)
	// Not implementation
	Chat(Chat_ChatServer) error
}

func RegisterChatServer(s *grpc.Server, srv ChatServer) {
	s.RegisterService(&_Chat_serviceDesc, srv)
}

func _Chat_Hello_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HelloRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServer).Hello(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chatpb.Chat/Hello",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServer).Hello(ctx, req.(*HelloRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Chat_Join_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(JoinRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ChatServer).Join(m, &chatJoinServer{stream})
}

type Chat_JoinServer interface {
	Send(*ChatMessage) error
	grpc.ServerStream
}

type chatJoinServer struct {
	grpc.ServerStream
}

func (x *chatJoinServer) Send(m *ChatMessage) error {
	return x.ServerStream.SendMsg(m)
}

func _Chat_SendChatMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChatMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServer).SendChatMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chatpb.Chat/SendChatMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServer).SendChatMessage(ctx, req.(*ChatMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Chat_Chat_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ChatServer).Chat(&chatChatServer{stream})
}

type Chat_ChatServer interface {
	Send(*ChatMessage) error
	Recv() (*ChatMessage, error)
	grpc.ServerStream
}

type chatChatServer struct {
	grpc.ServerStream
}

func (x *chatChatServer) Send(m *ChatMessage) error {
	return x.ServerStream.SendMsg(m)
}

func (x *chatChatServer) Recv() (*ChatMessage, error) {
	m := new(ChatMessage)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Chat_serviceDesc = grpc.ServiceDesc{
	ServiceName: "chatpb.Chat",
	HandlerType: (*ChatServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Hello",
			Handler:    _Chat_Hello_Handler,
		},
		{
			MethodName: "SendChatMessage",
			Handler:    _Chat_SendChatMessage_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Join",
			Handler:       _Chat_Join_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Chat",
			Handler:       _Chat_Chat_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "chat.proto",
}

func init() { proto.RegisterFile("chat.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 459 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xac, 0x93, 0xcf, 0x6e, 0xd3, 0x40,
	0x10, 0xc6, 0xb3, 0xae, 0x31, 0xcd, 0x24, 0x0d, 0xd6, 0x50, 0xaa, 0x28, 0xe2, 0x10, 0x2d, 0x3d,
	0x44, 0x3d, 0x58, 0x55, 0x40, 0x3d, 0x22, 0x91, 0x54, 0x88, 0x94, 0x3f, 0x8d, 0x36, 0x81, 0xbb,
	0x93, 0x2c, 0x89, 0x21, 0xf6, 0x18, 0xef, 0x16, 0xc4, 0x85, 0x27, 0xe6, 0x21, 0xd0, 0x6e, 0xd6,
	0xae, 0x81, 0x20, 0x71, 0xe8, 0xcd, 0x33, 0xf3, 0xdb, 0x9d, 0x6f, 0xbe, 0xf1, 0x02, 0x2c, 0x37,
	0xb1, 0x8e, 0xf2, 0x82, 0x34, 0x61, 0x60, 0xbe, 0xf3, 0x05, 0xbf, 0x82, 0xc3, 0xf7, 0x4a, 0x16,
	0x93, 0xec, 0x23, 0x61, 0x07, 0xbc, 0xc9, 0x65, 0x97, 0xf5, 0xd9, 0xc0, 0x17, 0xde, 0xe4, 0x12,
	0x11, 0xfc, 0x77, 0x71, 0x2a, 0xbb, 0x5e, 0x9f, 0x0d, 0x9a, 0xc2, 0x7e, 0x63, 0x0f, 0x0e, 0xa7,
	0xb1, 0x52, 0xdf, 0xa8, 0x58, 0x75, 0x0f, 0x6c, 0xbe, 0x8a, 0xf9, 0x29, 0xc0, 0x78, 0x9b, 0xc8,
	0x4c, 0xdb, 0xdb, 0x4e, 0x20, 0xf8, 0x20, 0x55, 0x42, 0x99, 0xbb, 0xd1, 0x45, 0xfc, 0x07, 0xb4,
	0x5f, 0xc9, 0xed, 0x96, 0x84, 0xfc, 0x72, 0x23, 0x95, 0xc6, 0xc7, 0xd0, 0x9c, 0x27, 0xa9, 0x9c,
	0xe9, 0x38, 0xcd, 0x1d, 0x7a, 0x9b, 0xc0, 0x53, 0xf0, 0x8d, 0x3e, 0xab, 0xa1, 0x35, 0x0c, 0xa3,
	0x9d, 0xec, 0xa8, 0xd4, 0x2c, 0x6c, 0x15, 0xcf, 0x20, 0xd8, 0x75, 0xb6, 0x9a, 0x5a, 0x43, 0x2c,
	0xb9, 0x5b, 0x3d, 0xc2, 0x11, 0x7c, 0x06, 0x47, 0xae, 0xbf, 0xca, 0x29, 0x53, 0x12, 0x07, 0xe0,
	0x8f, 0x69, 0x25, 0x6d, 0xef, 0xce, 0xf0, 0xb8, 0x3c, 0x5a, 0xd6, 0x4d, 0x4d, 0x58, 0x02, 0xbb,
	0x70, 0xff, 0xad, 0x54, 0x2a, 0x5e, 0x97, 0x9e, 0x94, 0x21, 0x27, 0x68, 0x8d, 0x37, 0xb1, 0x76,
	0x61, 0x1d, 0x64, 0xbf, 0x81, 0x66, 0x9e, 0x97, 0x05, 0xa5, 0xff, 0x9e, 0xc7, 0x54, 0xb1, 0x0f,
	0xde, 0x9c, 0xdc, 0x2c, 0x7f, 0x33, 0xde, 0x9c, 0xf8, 0x6b, 0x68, 0x5d, 0x51, 0x92, 0x95, 0x26,
	0x9e, 0x40, 0x20, 0x88, 0xd2, 0x6a, 0x7d, 0x2e, 0xfa, 0x3f, 0xfb, 0xb8, 0x80, 0xf6, 0x4c, 0x66,
	0xab, 0xbb, 0x74, 0xe4, 0xec, 0x05, 0xb4, 0xeb, 0x3c, 0x06, 0xe0, 0x5d, 0x7f, 0x0e, 0x1b, 0x08,
	0x10, 0x08, 0xf9, 0x49, 0x2e, 0x75, 0xc8, 0xb0, 0x03, 0x30, 0x8a, 0x57, 0x6e, 0x86, 0xd0, 0xc3,
	0x23, 0x68, 0x5e, 0x7f, 0x95, 0xc5, 0x9b, 0x24, 0x4d, 0x74, 0x78, 0x30, 0xfc, 0xc9, 0xc0, 0x37,
	0xae, 0xe2, 0x05, 0xdc, 0xb3, 0x2b, 0xc3, 0x4a, 0x4a, 0xfd, 0x0f, 0xea, 0x3d, 0xfa, 0x23, 0xbb,
	0xeb, 0xca, 0x1b, 0xf8, 0x0c, 0x7c, 0x63, 0x12, 0x3e, 0x2c, 0x81, 0x9a, 0x65, 0xbd, 0x2a, 0x59,
	0x5b, 0x1c, 0x6f, 0x9c, 0x33, 0x7c, 0x0e, 0x0f, 0x8c, 0x1b, 0xf5, 0x7d, 0xee, 0x63, 0x7b, 0x95,
	0x98, 0xba, 0x77, 0xbc, 0x81, 0x17, 0x4e, 0xf5, 0xde, 0x43, 0xfb, 0xbb, 0x0e, 0xd8, 0x39, 0x1b,
	0x3d, 0x81, 0xe3, 0x25, 0xa5, 0xd1, 0x3a, 0xd1, 0x9b, 0x9b, 0x45, 0xb4, 0xa6, 0xc5, 0x77, 0xcb,
	0x8e, 0x9a, 0x06, 0x9d, 0x9a, 0x57, 0x3b, 0x65, 0x8b, 0xc0, 0x3e, 0xdf, 0xa7, 0xbf, 0x02, 0x00,
	0x00, 0xff, 0xff, 0xb3, 0x63, 0x7e, 0xeb, 0xcc, 0x03, 0x00, 0x00,
}
